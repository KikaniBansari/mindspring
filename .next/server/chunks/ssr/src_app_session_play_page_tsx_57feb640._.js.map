{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/session/play/page.tsx"],"sourcesContent":["\n\"use client\";\n\n// Improved OverflowGridGame (replace your previous version)\nimport React, { useCallback, useEffect, useRef, useState } from \"react\";\nimport { AnimatePresence, motion } from \"framer-motion\";\nimport { ArrowUp, ArrowRight, ArrowDown, ArrowLeft } from \"lucide-react\";\n\nconst GRID_SIZE = 10;\nconst DIRECTIONS = [\"left\", \"right\", \"up\", \"down\"] as const;\ntype Direction = typeof DIRECTIONS[number];\n\ntype GridCell = {\n  type: \"empty\" | \"source\" | \"basin\" | \"redirector\";\n  direction?: Direction;\n  id?: number;\n};\ntype Particle = {\n  id: number;\n  // grid coords (integers)\n  gx: number;\n  gy: number;\n  // pixel coords for smooth rendering\n  px: number;\n  py: number;\n  dir: Direction;\n  path: { gx: number; gy: number }[];\n};\n\ntype OverflowGridProps = {\n  onThoughtsChange: React.Dispatch<React.SetStateAction<string>>;\n  initialThoughts?: string;\n};\n\nexport default function OverflowGridGame({\n  onThoughtsChange,\n  initialThoughts = \"\",\n}: OverflowGridProps) {\n  // refs & state\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const [grid, setGrid] = useState<GridCell[][]>(() =>\n    Array.from({ length: GRID_SIZE }, () =>\n      Array.from({ length: GRID_SIZE }, () => ({ type: \"empty\" } as GridCell))\n    )\n  );\n  const gridRef = useRef<GridCell[][]>(grid);\n  gridRef.current = grid;\n\n  const particlesRef = useRef<Particle[]>([]);\n  const [renderTick, setRenderTick] = useState(0); // small state to trigger react render\n  const particleId = useRef(1);\n  const animationFrameRef = useRef<number | null>(null);\n  const lastSpawnTimeRef = useRef<number>(0);\n  const runningRef = useRef(true);\n\n  const MAX_PARTICLES = 80;\n  const SPAWN_INTERVAL_MS = 800; // spawn rate per available source\n\n  // helpers: create empty grid copy\n  const createEmptyGrid = useCallback(\n    (): GridCell[][] =>\n      Array.from({ length: GRID_SIZE }, () =>\n        Array.from({ length: GRID_SIZE }, () => ({ type: \"empty\" } as GridCell))\n      ),\n    []\n  );\n\n  // get a random empty cell (safe)\n  const getRandomEmptyCell = useCallback((g: GridCell[][]) => {\n    const empties: { x: number; y: number }[] = [];\n    for (let y = 0; y < GRID_SIZE; y++) {\n      for (let x = 0; x < GRID_SIZE; x++) {\n        if (g[y][x].type === \"empty\") empties.push({ x, y });\n      }\n    }\n    if (empties.length === 0) return null;\n    return empties[Math.floor(Math.random() * empties.length)];\n  }, []);\n\n  // add a flow: mark a source and a basin with same id\n  const addNewFlow = useCallback((currentGrid: GridCell[][]) => {\n    const newGrid = currentGrid.map((row) => row.slice());\n    const a = getRandomEmptyCell(newGrid);\n    const b = getRandomEmptyCell(newGrid);\n    if (!a || !b) return newGrid;\n    const id = Date.now() + Math.floor(Math.random() * 1000);\n    newGrid[a.y][a.x] = { type: \"source\", id };\n    newGrid[b.y][b.x] = { type: \"basin\", id };\n    return newGrid;\n  }, [getRandomEmptyCell]);\n\n  // initialize grid with a couple flows\n  useEffect(() => {\n    let g = createEmptyGrid();\n    g = addNewFlow(g);\n    g = addNewFlow(g);\n    setGrid(g);\n  }, [addNewFlow, createEmptyGrid]);\n\n  // utility to rotate direction for redirector\n  const rotateDirection = (d?: Direction) =>\n    d ? DIRECTIONS[(DIRECTIONS.indexOf(d) + 1) % DIRECTIONS.length] : \"left\";\n\n  // API to toggle/rotate redirector on click/touch\n  const toggleRedirector = (row: number, col: number) => {\n    setGrid((prev) => {\n      const next = prev.map((r) => r.slice());\n      const cell = next[row][col];\n      if (cell.type === \"empty\") {\n        next[row][col] = { type: \"redirector\", direction: \"left\" };\n      } else if (cell.type === \"redirector\") {\n        next[row][col].direction = rotateDirection(cell.direction);\n      } else if (cell.type === \"source\" || cell.type === \"basin\") {\n        // maybe provide a small pulse feedback but don't overwrite\n      }\n      return next;\n    });\n  };\n\n  // spawn particle at a source cell (computes pixel positions later)\n  const spawnParticleFromSource = useCallback(\n    (sourceX: number, sourceY: number) => {\n      const id = particleId.current++;\n      const p: Particle = {\n        id,\n        gx: sourceX,\n        gy: sourceY,\n        px: 0,\n        py: 0,\n        dir: \"down\",\n        path: [{ gx: sourceX, gy: sourceY }],\n      };\n      particlesRef.current.push(p);\n    },\n    []\n  );\n\n  // remove basin flow by id and add a new flow\n  const absorbBasinAndReplace = useCallback(\n    (basinId: number) => {\n      setGrid((g) => {\n        const gcopy = g.map((row) => row.map((c) => ({ ...c })));\n        for (let y = 0; y < GRID_SIZE; y++) {\n          for (let x = 0; x < GRID_SIZE; x++) {\n            if (gcopy[y][x].id === basinId) gcopy[y][x] = { type: \"empty\" };\n          }\n        }\n        const withNew = addNewFlow(gcopy);\n        return withNew;\n      });\n      // nudge thoughts string (safe)\n      onThoughtsChange((prev) => prev + \".\");\n    },\n    [addNewFlow, onThoughtsChange]\n  );\n\n  // compute pixel position from grid coords\n  const gridCellRect = useCallback(() => {\n    const el = containerRef.current;\n    if (!el) return { cellW: 32, cellH: 32, left: 0, top: 0 };\n    const rect = el.getBoundingClientRect();\n    const cellW = rect.width / GRID_SIZE;\n    const cellH = rect.height / GRID_SIZE;\n    return { cellW, cellH, left: rect.left, top: rect.top, width: rect.width, height: rect.height };\n  }, []);\n\n  // main loop via requestAnimationFrame\n  useEffect(() => {\n    runningRef.current = true;\n    lastSpawnTimeRef.current = performance.now();\n\n    const loop = (now: number) => {\n      if (!runningRef.current) return;\n      // spawn logic: spawn probabilistically based on number of sources and spawn interval\n      const cellRect = gridCellRect();\n      const currentGrid = gridRef.current;\n      const sources = currentGrid.flatMap((row, y) =>\n        row.map((cell, x) => ({ ...cell, x, y })).filter((c) => c.type === \"source\")\n      );\n\n      // spawn if under MAX_PARTICLES and spawn interval passed\n      if (now - lastSpawnTimeRef.current > SPAWN_INTERVAL_MS && particlesRef.current.length < MAX_PARTICLES) {\n        lastSpawnTimeRef.current = now;\n        if (sources.length > 0) {\n          const src = sources[Math.floor(Math.random() * sources.length)];\n          spawnParticleFromSource(src.x, src.y);\n        }\n      }\n\n      // move particles one step toward their current direction\n      const newParticles: Particle[] = [];\n      for (const p of particlesRef.current) {\n        let nextX = p.gx,\n          nextY = p.gy,\n          nextDir = p.dir;\n        if (p.dir === \"up\") nextY -= 1;\n        if (p.dir === \"down\") nextY += 1;\n        if (p.dir === \"left\") nextX -= 1;\n        if (p.dir === \"right\") nextX += 1;\n\n        // out of bounds -> drop\n        if (nextX < 0 || nextX >= GRID_SIZE || nextY < 0 || nextY >= GRID_SIZE) {\n          continue;\n        }\n\n        const nextCell = currentGrid[nextY][nextX];\n\n        // if basin, absorb\n        if (nextCell.type === \"basin\") {\n          const basinId = nextCell.id!;\n          absorbBasinAndReplace(basinId);\n          continue; // particle removed\n        }\n\n        // if redirector exists, update direction\n        if (nextCell.type === \"redirector\" && nextCell.direction) {\n          nextDir = nextCell.direction;\n        }\n\n        // prevent infinite long path\n        if (p.path.length > 30) {\n          continue;\n        }\n\n        const updated: Particle = {\n          ...p,\n          gx: nextX,\n          gy: nextY,\n          dir: nextDir,\n          path: [...p.path, { gx: nextX, gy: nextY }],\n        };\n\n        // compute pixel positions (center of cell)\n        const px = nextX * cellRect.cellW + cellRect.cellW / 2 - 4; // -4 to center marker\n        const py = nextY * cellRect.cellH + cellRect.cellH / 2 - 4;\n        updated.px = px;\n        updated.py = py;\n\n        newParticles.push(updated);\n      }\n\n      // replace particle list\n      particlesRef.current = newParticles;\n\n      // trigger a react re-render occasionally, not every frame (throttle)\n      setRenderTick((t) => (t + 1) % 6);\n\n      animationFrameRef.current = requestAnimationFrame(loop);\n    };\n\n    animationFrameRef.current = requestAnimationFrame(loop);\n    return () => {\n      runningRef.current = false;\n      if (animationFrameRef.current) cancelAnimationFrame(animationFrameRef.current);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [gridCellRect, spawnParticleFromSource, absorbBasinAndReplace]);\n\n  // small helper to reset the grid & particles\n  const resetGame = () => {\n    particlesRef.current = [];\n    particleId.current = 1;\n    const g = createEmptyGrid();\n    const withFlows = addNewFlow(addNewFlow(g));\n    setGrid(withFlows);\n  };\n\n  // render redirector arrow\n  const renderRedirector = (dir?: Direction) => {\n    const className = \"text-green-600 transition-transform w-full h-full\";\n    switch (dir) {\n      case \"up\":\n        return <ArrowUp className={className} />;\n      case \"right\":\n        return <ArrowRight className={className} />;\n      case \"down\":\n        return <ArrowDown className={className} />;\n      case \"left\":\n        return <ArrowLeft className={className} />;\n      default:\n        return null;\n    }\n  };\n\n  // compute cell size style for container responsiveness\n  const [cellCssSize, setCellCssSize] = useState(\"32px\");\n  useEffect(() => {\n    const update = () => {\n      const el = containerRef.current;\n      if (!el) return;\n      const rect = el.getBoundingClientRect();\n      const size = Math.max(24, Math.min(48, Math.floor(rect.width / GRID_SIZE)));\n      setCellCssSize(`${size}px`);\n    };\n    update();\n    window.addEventListener(\"resize\", update);\n    return () => window.removeEventListener(\"resize\", update);\n  }, []);\n\n  // transform particlesRef.current into an array for rendering\n  const particlesToRender = particlesRef.current.slice();\n\n  return (\n    <div className=\"w-full h-full flex-1 flex flex-col items-center justify-center bg-green-100/30 rounded-2xl p-4 gap-2\">\n      <div className=\"flex items-center gap-2 mb-2\">\n        <p className=\"text-muted-foreground text-sm\">\n          Channel the overflowing thoughts into basins. Tap squares to place/rotate redirectors.\n        </p>\n        <button\n          onClick={resetGame}\n          className=\"ml-2 px-3 py-1 bg-white/60 rounded shadow text-sm text-foreground\"\n        >\n          Reset\n        </button>\n      </div>\n\n      <div\n        ref={containerRef}\n        className=\"relative\"\n        style={{ width: `calc(${GRID_SIZE} * ${cellCssSize})`, height: `calc(${GRID_SIZE} * ${cellCssSize})` }}\n        // touch handler for mobile (calculate cell from touch coords)\n        onTouchStart={(e) => {\n          const touch = e.touches[0];\n          if (!containerRef.current) return;\n          const rect = containerRef.current.getBoundingClientRect();\n          const x = Math.floor(((touch.clientX - rect.left) / rect.width) * GRID_SIZE);\n          const y = Math.floor(((touch.clientY - rect.top) / rect.height) * GRID_SIZE);\n          if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) toggleRedirector(y, x);\n        }}\n      >\n        {/* grid cells */}\n        {grid.map((row, y) =>\n          row.map((cell, x) => (\n            <div\n              key={`${y}-${x}-${cell.id || \"\"}`}\n              onClick={() => toggleRedirector(y, x)}\n              style={{\n                top: `calc(${y} * ${cellCssSize})`,\n                left: `calc(${x} * ${cellCssSize})`,\n                width: cellCssSize,\n                height: cellCssSize,\n              }}\n              className=\"absolute flex items-center justify-center border border-green-300/30 cursor-pointer select-none\"\n            >\n              {cell.type === \"source\" && <div className=\"w-3/4 h-3/4 rounded-full bg-green-500 animate-pulse\" />}\n              {cell.type === \"basin\" && <div className=\"w-3/4 h-3/4 rounded-full border-4 border-green-700\" />}\n              {cell.type === \"redirector\" && cell.direction && renderRedirector(cell.direction)}\n            </div>\n          ))\n        )}\n\n        {/* particles */}\n        <AnimatePresence>\n          {particlesToRender.map((p) => (\n            <motion.div\n              key={p.id}\n              initial={{ opacity: 0, scale: 0.5, left: p.px, top: p.py }}\n              animate={{ opacity: 1, scale: 1, left: p.px, top: p.py }}\n              exit={{ opacity: 0, scale: 0 }}\n              transition={{ duration: 0.12, ease: \"linear\" }}\n              style={{\n                position: \"absolute\",\n                width: 8,\n                height: 8,\n                borderRadius: 999,\n                background: \"#86efac\",\n                left: p.px,\n                top: p.py,\n                transform: \"translate(-50%,-50%)\",\n                boxShadow: \"0 0 6px rgba(134,239,172,0.7)\",\n              }}\n            />\n          ))}\n        </AnimatePresence>\n      </div>\n    </div>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}